> {-# OPTIONS -ffi -fglasgow-exts #-}

|
Module      :  Database.PostgreSQL.PGFunctions
Copyright   :  (c) 2004 Oleg Kiselyov, Alistair Bayley
License     :  BSD-style
Maintainer  :  oleg@pobox.com, alistair@abayley.org
Stability   :  experimental
Portability :  non-portable
 
Simple wrappers for PostgreSQL functions (FFI).


> module Database.PostgreSQL.PGFunctions where

> -- import Foreign.C.Unicode
> import Foreign
> import Foreign.C
> import Foreign.Ptr
> import Control.Monad
> import Control.Exception
> import Data.Dynamic
> import Data.Int


> data DBHandleStruct = PGconn
> type DBHandle = Ptr DBHandleStruct
> data StmtStruct = PGresult
> type StmtHandle = Ptr StmtStruct
> type Oid = CUInt -- from postgres_ext.h
> invalidOid = 0
> -- type Blob = Ptr Word8

> data PGException = PGException Int String
>   deriving (Typeable)

> instance Show PGException where
>   show (PGException i s) = "PGException " ++ (show i) ++ " " ++ s

> catchPG :: IO a -> (PGException -> IO a) -> IO a
> catchPG = catchDyn

> throwPG :: Integral a => a -> String -> b
> throwPG rc s = throwDyn (PGException (fromIntegral rc) s)

> cStr :: CStringLen -> CString
> cStr = fst
> cStrLen :: CStringLen -> CInt
> cStrLen = fromIntegral . snd


 type UTF16CString = CString
 type UTF8CString = CString


> foreign import ccall "libpq-fe.h PQconnectdb" fPQconnectdb
>   :: CString -> IO DBHandle

> foreign import ccall "libpq-fe.h PQfinish" fPQfinish
>   :: DBHandle -> IO ()

From the PostgreSQL 8.0.0 docs, postgresql/libpq.html:

    This function will close the connection to the server and attempt to
    reestablish a new connection to the same server, using all the same
    parameters previously used. This may be useful for error recovery if a
    working connection is lost.

> foreign import ccall "libpq-fe.h PQreset" fPQreset
>   :: DBHandle -> IO ()

Returns the database name of the connection
This is guaranteed by the Postgresql documentation to be a pure function

> foreign import ccall "libpq-fe.h PQdb" fPQdb
>   :: DBHandle -> CString

Inquire the connection status

> type ConnStatusType = CInt -- enumeration, see libpq-fe.h
> [eCONNECTION_OK,eCONNECTION_BAD] = [0..1]::[ConnStatusType]
> foreign import ccall "libpq-fe.h PQstatus" fPQstatus
>   :: DBHandle -> IO ConnStatusType

Returns the error message most recently generated by an operation on the
connection.

> foreign import ccall "libpq-fe.h PQerrorMessage" fPQerrorMessage
>   :: DBHandle -> IO CString

Execution of commands

> foreign import ccall "libpq-fe.h PQexec" fPQexec
>   :: DBHandle -> CString -> IO StmtHandle

> foreign import ccall "libpq-fe.h PQresultStatus" fPQresultStatus
>   :: StmtHandle -> IO ExecStatusType


> type ExecStatusType = CInt -- enumeration, see libpq-fe.h
> (ePGRES_EMPTY_QUERY : 
>  ePGRES_COMMAND_OK : 
>  ePGRES_TUPLES_OK :
>  ePGRES_COPY_OUT : 
>  ePGRES_COPY_IN : 
>  ePGRES_BAD_RESPONSE :
>  ePGRES_NONFATAL_ERROR : 
>  ePGRES_FATAL_ERROR : 
>  _)
>  = [0..] :: [ExecStatusType]

> foreign import ccall "libpq-fe.h PQresultErrorMessage" fPQresultErrorMessage
>   :: StmtHandle -> IO CString

> foreign import ccall "libpq-fe.h PQclear" fPQclear
>   :: StmtHandle -> IO ()


Retrieving Query Result Information

> foreign import ccall "libpq-fe.h PQntuples" fPQntuples
>   :: StmtHandle -> IO CInt
> foreign import ccall "libpq-fe.h PQnfields" fPQnfields
>   :: StmtHandle -> IO CInt

Inquiry about a column

> foreign import ccall "libpq-fe.h PQfname" fPQfname
>   :: StmtHandle -> CInt -> IO CString
> foreign import ccall "libpq-fe.h PQfformat" fPQfformat
>   :: StmtHandle -> CInt -> IO CInt
> foreign import ccall "libpq-fe.h PQftype" fPQftype
>   :: StmtHandle -> CInt -> IO Oid

Really getting the values

> foreign import ccall "libpq-fe.h PQgetvalue" fPQgetvalue
>   :: StmtHandle -> CInt -> CInt -> IO (Ptr Word8)
> foreign import ccall "libpq-fe.h PQgetisnull" fPQgetisnull
>   :: StmtHandle -> CInt -> CInt -> IO CInt
> foreign import ccall "libpq-fe.h PQgetlength" fPQgetlength
>   :: StmtHandle -> CInt -> CInt -> IO CInt

27.3.3. Retrieving Result Information for Other Commands

> foreign import ccall "libpq-fe.h PQcmdStatus" fPQcmdStatus
>   :: StmtHandle -> IO CString
> foreign import ccall "libpq-fe.h PQcmdTuples" fPQcmdTuples
>   :: StmtHandle -> IO CString
> foreign import ccall "libpq-fe.h PQoidValue" fPQoidValue
>   :: StmtHandle -> IO Oid


> {-
> foreign import ccall "libpq-fe.h sqlite3_prepare" sqlitePrepare
>   :: DBHandle -> UTF8CString -> CInt -> Ptr StmtHandle -> Ptr CString -> IO CInt

> foreign import ccall "libpq-fe.h sqlite3_bind_text" sqliteBindText
>   :: StmtHandle -> CInt -> UTF8CString -> CInt -> FreeFunPtr -> IO CInt
> -}

-------------------------------------------------------------------

Get the current error message

> getError :: DBHandle -> IO String
> getError db = fPQerrorMessage db >>= peekCString

> {-
> getError :: DBHandle -> IO PGException
> getError db = do
>   errcodec <- sqliteErrcode db
>   errmsgc <- sqliteErrmsg db
>   errmsg <- peekUTF8String errmsgc
>   return $ PGException (fromIntegral errcodec) errmsg

> getAndRaiseError :: DBHandle -> IO a
> getAndRaiseError db = do
>   ex <- getError db
>   throwPG ex

> testForError :: DBHandle -> CInt -> a -> IO a
> testForError db rc retval = do
>   case () of
>     _ | rc == sqliteOK -> return retval
>       | rc == sqliteDONE -> return retval
>       | rc == sqliteROW -> return retval
>       | otherwise -> getAndRaiseError db

> testForErrorWithPtr :: (Storable a) => DBHandle -> CInt -> Ptr a -> IO a
> testForErrorWithPtr db rc ptr = do
>   -- wrap peek in action like this so that we can
>   -- ensure it's performed only after we've tested rc
>   let peekAction = do
>       v <- peek ptr
>       return v
>   case () of
>     _ | rc == sqliteOK -> peekAction
>       | rc == sqliteDONE -> peekAction
>       | rc == sqliteROW -> peekAction
>       | otherwise -> getAndRaiseError db
> -}

conn'parm is a string with all the attributes

> openDb :: String -> IO DBHandle
> openDb conn'parm =
>   withCString conn'parm $ \cstr -> do
>   db <- fPQconnectdb cstr
>   if db == nullPtr
>     then throwPG (-1) "Null PGconn handle from PQconnectdb"
>     else do
>     rc <- fPQstatus db
>     if rc == eCONNECTION_OK
>       then return db
>       else do
>         emsg <- getError db
>         fPQfinish db
>         throwPG rc emsg

> closeDb :: DBHandle -> IO ()
> closeDb db = fPQfinish db

Check the StmtHandle returned by fPQexec and similar functions

> check'stmt :: DBHandle -> ExecStatusType -> StmtHandle -> IO StmtHandle
> check'stmt db _ stmt | stmt == nullPtr = -- something is really wrong
>      do emsg <- getError db 
>         rc   <- fPQstatus db
>         throwPG rc emsg
> check'stmt _ expected'status stmt = 
>      do 
>         rc <- fPQresultStatus stmt
>         if rc == expected'status then return stmt
>            else do
>                    msg <- fPQresultErrorMessage stmt >>= peekCString
>                    fPQclear stmt
>                    throwPG rc msg
> 


Execute some kind of statement, which returns no tuples

> nqExec :: DBHandle -> String -> IO (String, String, Oid)
> nqExec db sqlText =
>   withCString sqlText $ \cstr -> 
>     do
>     stmt <- fPQexec db cstr >>= check'stmt db ePGRES_COMMAND_OK
>     -- save all information from PGresult and free it
>     cmd'status  <- fPQcmdStatus stmt >>= peekCString
>     cmd'ntuples <- fPQcmdTuples stmt >>= peekCString
>     cmd'oid     <- fPQoidValue stmt
>     fPQclear stmt
>     return (cmd'status, cmd'ntuples, cmd'oid)


> stmtExec :: DBHandle -> String -> IO StmtHandle
> stmtExec db sqlText =
>   withCString sqlText $ \cstr ->
>     fPQexec db cstr >>= check'stmt db ePGRES_TUPLES_OK

Free storage, that is. No error in Postgres

> stmtFinalise :: StmtHandle -> IO ()
> stmtFinalise = fPQclear

> {-
> stmtPrepare :: DBHandle -> String -> IO StmtHandle
> stmtPrepare db sqlText =
>   withUTF8StringLen sqlText $ \(cstr, clen) ->
>   alloca $ \stmtptr ->
>   alloca $ \unusedptr -> do
>     rc <- sqlitePrepare db cstr (fromIntegral clen) stmtptr unusedptr
>     testForErrorWithPtr db rc stmtptr

> stmtFetch :: DBHandle -> StmtHandle -> IO CInt
> stmtFetch db stmt = do
>   rc <- sqliteStep stmt
>   testForError db rc rc


|Column numbers are zero-indexed, so subtract one
from given index (we present a one-indexed interface).

> colValInt :: StmtHandle -> Int -> IO Int
> colValInt stmt colnum = do
>   cint <- sqliteColumnInt stmt (fromIntegral (colnum - 1))
>   return (fromIntegral cint)

> colValInt64 :: StmtHandle -> Int -> IO Int64
> colValInt64 stmt colnum = do
>   cllong <- sqliteColumnInt64 stmt (fromIntegral (colnum - 1))
>   return (fromIntegral cllong)

> colValDouble :: StmtHandle -> Int -> IO Double
> colValDouble stmt colnum = do
>   cdbl <- sqliteColumnDouble stmt (fromIntegral (colnum - 1))
>   return (realToFrac cdbl)

> colValString :: StmtHandle -> Int -> IO String
> colValString stmt colnum = do
>   cstrptr <- sqliteColumnText stmt (fromIntegral (colnum - 1))
>   if cstrptr == nullPtr
>     then return ""
>     else do
>       str <- peekUTF8String cstrptr
>       return str

> colValBlob :: StmtHandle -> Int -> IO (ForeignPtr Blob)
> colValBlob stmt colnum = do
>   let ccolnum = fromIntegral (colnum - 1)
>   bytes <- sqliteColumnBytes stmt ccolnum
>   src <- sqliteColumnBlob stmt ccolnum
>   buffer <- mallocForeignPtrBytes bytes
>   withForeignPtr buffer $ \dest -> copyBytes dest src bytes
>   return (castForeignPtr buffer)


Unlike column numbers, bind positions are 1-indexed,
so there's no need to subtract one from the given position.

> bindDouble :: DBHandle -> StmtHandle -> Int -> Double -> IO ()
> bindDouble db stmt pos value = do
>   rc <- sqliteBindDouble stmt (fromIntegral pos) (realToFrac value)
>   testForError db rc ()

> bindInt :: DBHandle -> StmtHandle -> Int -> Int -> IO ()
> bindInt db stmt pos value = do
>   rc <- sqliteBindInt stmt (fromIntegral pos) (fromIntegral value)
>   testForError db rc ()

> bindInt64 :: DBHandle -> StmtHandle -> Int -> Int64 -> IO ()
> bindInt64 db stmt pos value = do
>   rc <- sqliteBindInt64 stmt (fromIntegral pos) (fromIntegral value)
>   testForError db rc ()

> bindNull :: DBHandle -> StmtHandle -> Int -> IO ()
> bindNull db stmt pos = do
>   rc <- sqliteBindNull stmt (fromIntegral pos)
>   testForError db rc ()

> bindString :: DBHandle -> StmtHandle -> Int -> String -> IO ()
> bindString db stmt pos value =
>   withUTF8StringLen value $ \(cstr, clen) -> do
>     rc <- sqliteBindText stmt (fromIntegral pos) cstr (fromIntegral clen) nullFunPtr
>     testForError db rc ()

> bindBlob :: DBHandle -> StmtHandle -> Int -> Blob -> Int -> IO ()
> bindBlob db stmt pos value size = do
>   rc <- sqliteBindBlob stmt (fromIntegral pos) value (fromIntegral size) nullFunPtr
>   testForError db rc ()

> -}
