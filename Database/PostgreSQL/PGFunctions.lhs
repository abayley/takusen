> {-# OPTIONS -ffi -fglasgow-exts #-}

|
Module      :  Database.PostgreSQL.PGFunctions
Copyright   :  (c) 2004 Oleg Kiselyov, Alistair Bayley
License     :  BSD-style
Maintainer  :  oleg@pobox.com, alistair@abayley.org
Stability   :  experimental
Portability :  non-portable
 
Simple wrappers for PostgreSQL functions (FFI) plus middle-level
wrappers (in the second part of this file)


> module Database.PostgreSQL.PGFunctions where

> -- import Foreign.C.Unicode
> import Foreign
> import Foreign.C
> import Foreign.Ptr
> import Control.Monad
> import Control.Exception
> import Data.Dynamic
> import Data.Int


> data DBHandleStruct = PGconn
> type DBHandle = Ptr DBHandleStruct
> data StmtStruct = PGresult
> type StmtHandle = Ptr StmtStruct
> type Oid = CUInt -- from postgres_ext.h
> invalidOid = 0
> -- type Blob = Ptr Word8

> data PGException = PGException Int String
>   deriving (Typeable)

> instance Show PGException where
>   show (PGException i s) = "PGException " ++ (show i) ++ " " ++ s

> catchPG :: IO a -> (PGException -> IO a) -> IO a
> catchPG = catchDyn

> throwPG :: Integral a => a -> String -> any
> throwPG rc s = throwDyn (PGException (fromIntegral rc) s)

> rethrowPG :: PGException -> any
> rethrowPG = throwDyn

> cStr :: CStringLen -> CString
> cStr = fst
> cStrLen :: CStringLen -> CInt
> cStrLen = fromIntegral . snd


> foreign import ccall "libpq-fe.h PQconnectdb" fPQconnectdb
>   :: CString -> IO DBHandle

> foreign import ccall "libpq-fe.h PQfinish" fPQfinish
>   :: DBHandle -> IO ()

From the PostgreSQL 8.0.0 docs, postgresql/libpq.html:

    This function will close the connection to the server and attempt to
    reestablish a new connection to the same server, using all the same
    parameters previously used. This may be useful for error recovery if a
    working connection is lost.

> foreign import ccall "libpq-fe.h PQreset" fPQreset
>   :: DBHandle -> IO ()

Returns the database name of the connection
This is guaranteed by the Postgresql documentation to be a pure function

> foreign import ccall "libpq-fe.h PQdb" fPQdb
>   :: DBHandle -> CString

Inquire the connection status

> type ConnStatusType = CInt -- enumeration, see libpq-fe.h
> [eCONNECTION_OK,eCONNECTION_BAD] = [0..1]::[ConnStatusType]
> foreign import ccall "libpq-fe.h PQstatus" fPQstatus
>   :: DBHandle -> IO ConnStatusType

Returns the error message most recently generated by an operation on the
connection.

> foreign import ccall "libpq-fe.h PQerrorMessage" fPQerrorMessage
>   :: DBHandle -> IO CString

Execution of commands

> foreign import ccall "libpq-fe.h PQexec" fPQexec
>   :: DBHandle -> CString -> IO StmtHandle

One can also use SQL PREPARE for that

> foreign import ccall "libpq-fe.h PQprepare" fPQprepare
>   :: DBHandle -> CString -> CString -> CInt -> Ptr Oid -> IO StmtHandle

> foreign import ccall "libpq-fe.h PQexecPrepared" fPQexecPrepared
>   :: DBHandle -> CString -> CInt -> Ptr CString -> Ptr CInt -> Ptr CInt ->
>      CInt -> IO StmtHandle



> foreign import ccall "libpq-fe.h PQresultStatus" fPQresultStatus
>   :: StmtHandle -> IO ExecStatusType

> type ExecStatusType = CInt -- enumeration, see libpq-fe.h
> (ePGRES_EMPTY_QUERY : 
>  ePGRES_COMMAND_OK : 
>  ePGRES_TUPLES_OK :
>  ePGRES_COPY_OUT : 
>  ePGRES_COPY_IN : 
>  ePGRES_BAD_RESPONSE :
>  ePGRES_NONFATAL_ERROR : 
>  ePGRES_FATAL_ERROR : 
>  _)
>  = [0..] :: [ExecStatusType]

> foreign import ccall "libpq-fe.h PQresultErrorMessage" fPQresultErrorMessage
>   :: StmtHandle -> IO CString

> foreign import ccall "libpq-fe.h PQclear" fPQclear
>   :: StmtHandle -> IO ()


Retrieving Query Result Information

> foreign import ccall "libpq-fe.h PQntuples" fPQntuples
>   :: StmtHandle -> IO CInt
> foreign import ccall "libpq-fe.h PQnfields" fPQnfields
>   :: StmtHandle -> IO CInt

Inquiry about a column; Column numbers start at 0

> foreign import ccall "libpq-fe.h PQfname" fPQfname
>   :: StmtHandle -> CInt -> IO CString
> foreign import ccall "libpq-fe.h PQfformat" fPQfformat
>   :: StmtHandle -> CInt -> IO CInt
> foreign import ccall "libpq-fe.h PQftype" fPQftype
>   :: StmtHandle -> CInt -> IO Oid

Really getting the values

> foreign import ccall "libpq-fe.h PQgetvalue" fPQgetvalue
>   :: StmtHandle -> CInt -> CInt -> IO (Ptr Word8)
> foreign import ccall "libpq-fe.h PQgetisnull" fPQgetisnull
>   :: StmtHandle -> CInt -> CInt -> IO CInt
> foreign import ccall "libpq-fe.h PQgetlength" fPQgetlength
>   :: StmtHandle -> CInt -> CInt -> IO CInt

27.3.3. Retrieving Result Information for Other Commands

> foreign import ccall "libpq-fe.h PQcmdStatus" fPQcmdStatus
>   :: StmtHandle -> IO CString
> foreign import ccall "libpq-fe.h PQcmdTuples" fPQcmdTuples
>   :: StmtHandle -> IO CString
> foreign import ccall "libpq-fe.h PQoidValue" fPQoidValue
>   :: StmtHandle -> IO Oid

27.9. Control Functions

> type PGVerbosity = CInt -- enumeration, see libpq-fe.h
> (ePQERRORS_TERSE : 
>  ePQERRORS_DEFAULT :
>  ePQERRORS_VERBOSE :
>  _) = [0..]::[PGVerbosity]
> foreign import ccall "libpq-fe.h PQsetErrorVerbosity" fPQsetErrorVerbosity
>   :: DBHandle -> PGVerbosity -> IO PGVerbosity



-------------------------------------------------------------------
			Middle-level interface

Get the current error message

> getError :: DBHandle -> IO String
> getError db = fPQerrorMessage db >>= peekCString

> {-
> getError :: DBHandle -> IO PGException
> getError db = do
>   errcodec <- sqliteErrcode db
>   errmsgc <- sqliteErrmsg db
>   errmsg <- peekUTF8String errmsgc
>   return $ PGException (fromIntegral errcodec) errmsg

> getAndRaiseError :: DBHandle -> IO a
> getAndRaiseError db = do
>   ex <- getError db
>   throwPG ex

> testForErrorWithPtr :: (Storable a) => DBHandle -> CInt -> Ptr a -> IO a
> testForErrorWithPtr db rc ptr = do
>   -- wrap peek in action like this so that we can
>   -- ensure it's performed only after we've tested rc
>   let peekAction = do
>       v <- peek ptr
>       return v
>   case () of
>     _ | rc == sqliteOK -> peekAction
>       | rc == sqliteDONE -> peekAction
>       | rc == sqliteROW -> peekAction
>       | otherwise -> getAndRaiseError db
> -}

conn'parm is a string with all the attributes

> openDb :: String -> IO DBHandle
> openDb conn'parm =
>   withCString conn'parm $ \cstr -> do
>   db <- fPQconnectdb cstr
>   if db == nullPtr
>     then throwPG (-1) "Null PGconn handle from PQconnectdb"
>     else do
>     rc <- fPQstatus db
>     if rc == eCONNECTION_OK
>       then return db
>       else do
>         emsg <- getError db
>         fPQfinish db
>         throwPG rc emsg

> closeDb :: DBHandle -> IO ()
> closeDb db = fPQfinish db

Check the StmtHandle returned by fPQexec and similar functions

> check'stmt :: DBHandle -> ExecStatusType -> StmtHandle -> IO StmtHandle
> check'stmt db _ stmt | stmt == nullPtr = -- something is really wrong
>      do emsg <- getError db 
>         rc   <- fPQstatus db
>         throwPG rc emsg
> check'stmt _ expected'status stmt = 
>      do 
>         rc <- fPQresultStatus stmt
>         if rc == expected'status then return stmt
>            else do
>                    msg <- fPQresultErrorMessage stmt >>= peekCString
>                    fPQclear stmt
>                    throwPG rc msg



Execute some kind of statement that returns no tuples

> nqExec :: DBHandle -> String -> IO (String, String, Oid)
> nqExec db sqlText =
>   withCString sqlText $ \cstr -> 
>     do
>     stmt <- fPQexec db cstr >>= check'stmt db ePGRES_COMMAND_OK
>     -- save all information from PGresult and free it
>     cmd'status  <- fPQcmdStatus stmt >>= peekCString
>     cmd'ntuples <- fPQcmdTuples stmt >>= peekCString
>     cmd'oid     <- fPQoidValue stmt
>     fPQclear stmt
>     return (cmd'status, cmd'ntuples, cmd'oid)


Prepare and Execute a query

> stmtExecImm :: DBHandle -> String -> IO (StmtHandle, Int)
> stmtExecImm db sqlText =
>   withCString sqlText $ \cstr ->
>     do 
>     stmt <- fPQexec db cstr >>= check'stmt db ePGRES_TUPLES_OK
>     ntuples <- fPQntuples stmt
>     return (stmt, fromIntegral ntuples)


Currently assume all parameters, if any, are text

> stmtPrepare :: DBHandle -> String -> String -> IO String
> stmtPrepare db stmt'name sqlText =
>   withCString stmt'name $ \csn ->
>     withCString sqlText $ \cstr ->
>       do
>       stmt <- fPQprepare db csn cstr 0 nullPtr >>= 
>                     check'stmt db ePGRES_COMMAND_OK
>       fPQclear stmt			-- doesn't have any useful info
>       return stmt'name


Execute a previously prepared statement, with no params. Ask for the
result in text

> stmtExec0 :: DBHandle -> String -> IO (StmtHandle, Int)
> stmtExec0 db stmt'name =
>   withCString stmt'name $ \csn ->
>     do 
>     stmt <- fPQexecPrepared db csn 0 nullPtr nullPtr nullPtr 0 >>=
>		   check'stmt db ePGRES_TUPLES_OK
>     ntuples <- fPQntuples stmt
>     return (stmt, fromIntegral ntuples)



Free storage, that is. No error in Postgres

> stmtFinalise :: StmtHandle -> IO ()
> stmtFinalise = fPQclear

|Column numbers are zero-indexed, so subtract one
from given index (we present a one-indexed interface).
So are the row numbers

> colValString :: StmtHandle -> Int -> Int -> IO String
> colValString stmt rownum colnum = do
>   ptr <- fPQgetvalue stmt (fromIntegral (rownum - 1))
>                           (fromIntegral (colnum - 1))
>   peekCString (castPtr ptr)

> {-
> colValInt64 :: StmtHandle -> Int -> IO Int64
> colValInt64 stmt colnum = do
>   cllong <- sqliteColumnInt64 stmt (fromIntegral (colnum - 1))
>   return (fromIntegral cllong)

> colValDouble :: StmtHandle -> Int -> IO Double
> colValDouble stmt colnum = do
>   cdbl <- sqliteColumnDouble stmt (fromIntegral (colnum - 1))
>   return (realToFrac cdbl)

> colValString :: StmtHandle -> Int -> IO String
> colValString stmt colnum = do
>   cstrptr <- sqliteColumnText stmt (fromIntegral (colnum - 1))
>   if cstrptr == nullPtr
>     then return ""
>     else do
>       str <- peekUTF8String cstrptr
>       return str

> colValBlob :: StmtHandle -> Int -> IO (ForeignPtr Blob)
> colValBlob stmt colnum = do
>   let ccolnum = fromIntegral (colnum - 1)
>   bytes <- sqliteColumnBytes stmt ccolnum
>   src <- sqliteColumnBlob stmt ccolnum
>   buffer <- mallocForeignPtrBytes bytes
>   withForeignPtr buffer $ \dest -> copyBytes dest src bytes
>   return (castForeignPtr buffer)


Unlike column numbers, bind positions are 1-indexed,
so there's no need to subtract one from the given position.

> bindDouble :: DBHandle -> StmtHandle -> Int -> Double -> IO ()
> bindDouble db stmt pos value = do
>   rc <- sqliteBindDouble stmt (fromIntegral pos) (realToFrac value)
>   testForError db rc ()

> bindInt :: DBHandle -> StmtHandle -> Int -> Int -> IO ()
> bindInt db stmt pos value = do
>   rc <- sqliteBindInt stmt (fromIntegral pos) (fromIntegral value)
>   testForError db rc ()

> bindInt64 :: DBHandle -> StmtHandle -> Int -> Int64 -> IO ()
> bindInt64 db stmt pos value = do
>   rc <- sqliteBindInt64 stmt (fromIntegral pos) (fromIntegral value)
>   testForError db rc ()

> bindNull :: DBHandle -> StmtHandle -> Int -> IO ()
> bindNull db stmt pos = do
>   rc <- sqliteBindNull stmt (fromIntegral pos)
>   testForError db rc ()

> bindString :: DBHandle -> StmtHandle -> Int -> String -> IO ()
> bindString db stmt pos value =
>   withUTF8StringLen value $ \(cstr, clen) -> do
>     rc <- sqliteBindText stmt (fromIntegral pos) cstr (fromIntegral clen) nullFunPtr
>     testForError db rc ()

> bindBlob :: DBHandle -> StmtHandle -> Int -> Blob -> Int -> IO ()
> bindBlob db stmt pos value size = do
>   rc <- sqliteBindBlob stmt (fromIntegral pos) value (fromIntegral size) nullFunPtr
>   testForError db rc ()

> -}
